LOAD CSV WITH HEADERS FROM '%dataImportLink%/csv/initmc.csv' AS line

MATCH (a:Agreement {id:line.AgreementId})
MATCH (c:Client)-[:MANAGES]->(e:LegalEntity)-[s:CLIENT_SIGNS]->(a)<-[:COUNTERPARTY_SIGNS]-(ce)
MATCH (ms:MarginStatement {id:line.StatementId})

WITH *, CASE WHEN line.MarginType = 'Initial' THEN [1] ELSE [] END as initial
WITH *, CASE WHEN line.MarginType = 'Variation' AND (a.type = 'legacy' OR a.type = 'bilateral') THEN [1] ELSE [] END as variation1
WITH *, CASE WHEN line.MarginType = 'Variation' AND (a.type <> 'legacy' AND a.type <> 'bilateral') THEN [1] ELSE [] END as variation2
WITH *, CASE WHEN line.MarginType = 'InterestPayment' THEN [1] ELSE [] END as IP
WITH *, CASE WHEN line.MarginType = 'ProductCashFlow' THEN [1] ELSE [] END as PCF
WITH *, CASE WHEN line.MarginType = 'PAI' THEN [1] ELSE [] END as PAI
WITH *, CASE WHEN line.MarginType = 'FeesAndComms' THEN [1] ELSE [] END as FC

FOREACH (i in initial | MERGE (mc:InitialMargin:StatementItem:MarginCall {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, excessAmount:toFloat(line.ExcessAmount), marginAmount:toFloat(line.TotalCallAmount), marginAmount:toFloat(line.TotalCallAmount), returnAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.DeliverAmount), balanceAmount:toFloat(line.CollateralValue), pendingCollateral:toFloat(line.PendingCollateral), exposure:toFloat(line.Exposure), IMRole:line.IMRole, exchangeRequirement:toFloat(line.Exposure), brokerRequirement:toFloat(line.Exposure)*a.brokerMultiplier, initialBalanceCash:s.initialBalanceCash, initialBalanceNonCash:s.initialBalanceNonCash}))

FOREACH (i in variation1 | MERGE (mc:VariationMargin:StatementItem:MarginCall {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, excessAmount:toFloat(line.ExcessAmount), marginAmount:toFloat(line.TotalCallAmount), marginAmount:toFloat(line.TotalCallAmount), returnAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.DeliverAmount), balanceAmount:toFloat(line.CollateralValue), pendingCollateral:toFloat(line.PendingCollateral), exposure:toFloat(line.Exposure), ampId:line.AmpId}))

FOREACH (i in variation2 | MERGE (mc:VariationMargin:StatementItem:MarginCall {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, excessAmount:toFloat(line.ExcessAmount), marginAmount:toFloat(line.TotalCallAmount), marginAmount:toFloat(line.TotalCallAmount), returnAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.DeliverAmount), balanceAmount:toFloat(line.CollateralValue), pendingCollateral:toFloat(line.PendingCollateral), exposure:toFloat(line.Exposure)}))

FOREACH (i in IP | MERGE (mc:InterestPayment:StatementItem {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, marginAmount:toFloat(line.TotalCallAmount)}))

FOREACH (i in PCF | MERGE (mc:ProductCashFlow:StatementItem {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, totalCouponPayment:toFloat(line.TotalCouponPayment), upfrontFee:toFloat(line.UpfrontFee), premiumPayment:toFloat(line.PremiumPayment), CDSCreditEvent:toFloat(line.CDSCreditEvent), NDFCashSettlement:toFloat(line.NDFCashSettlement), marginAmount:toFloat(line.TotalCallAmount)}))

FOREACH (i in PAI | MERGE (mc:PAI:StatementItem {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, marginAmount:toFloat(line.TotalCallAmount)}))

FOREACH (i in FC | MERGE (mc:FeesAndComms:StatementItem {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, clearingFee:toFloat(line.ClearingFee), brokerFee:toFloat(line.BrokerFee), marginAmount:toFloat(line.TotalCallAmount)}))

WITH *

MATCH (mc:StatementItem {id:line.CallId})

SET mc.notificationTime = mc.callDate + 'T' + a.notificationTime

MERGE (mc)-[:FIRST]->(step1:Step {status:'Unrecon'})
MERGE (mc)-[:LAST]->(step1)

MERGE (mc)-[:PART_OF]->(ms)

WITH *

MATCH (step2:Step {status:'Expected'})<-[r:LAST]-(mce:StatementItem {callDate:line.CallDate, marginType:line.MarginType, status:'Expected', currency:line.Currency})-[:PART_OF]->(ms)

DELETE r

MERGE (step2)-[:NEXT]->(:Step {status:'MatchedToReceived'})<-[:LAST]-(mce)

MERGE (mce)<-[:MATCHED_TO_EXPECTED]-(mc)
