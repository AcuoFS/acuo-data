LOAD CSV WITH HEADERS FROM '%dataImportLink%/csv/initmc.csv' AS line

MATCH (a:Agreement {id:line.AgreementId})
MATCH (c:Client)-[:MANAGES]->(e:LegalEntity)-[s:CLIENT_SIGNS]->(a)<-[:COUNTERPARTY_SIGNS]-(ce)
MATCH (ms:MarginStatement {id:line.StatementId})
OPTIONAL MATCH (ms)-[:BALANCE]-[:Collateral {marginType:'initial',status:'pending',assetType:'cash'}]-[:LATEST]->(initialPendingCash:CollateralValue)
OPTIONAL MATCH (ms)-[:BALANCE]-[:Collateral {marginType:'initial',status:'pending',assetType:'NonCash'}]-[:LATEST]->(initialPendingNonCash:CollateralValue)
OPTIONAL MATCH (ms)-[:BALANCE]-[:Collateral {marginType:'initial',status:'settled',assetType:'cash'}]-[:LATEST]->(initialSettledCash:CollateralValue)
OPTIONAL MATCH (ms)-[:BALANCE]-[:Collateral {marginType:'initial',status:'settled',assetType:'NonCash'}]-[:LATEST]->(initialSettledNonCash:CollateralValue)
OPTIONAL MATCH (ms)-[:BALANCE]-[:Collateral {marginType:'variation',status:'pending',assetType:'cash'}]-[:LATEST]->(variationPendingCash:CollateralValue)
OPTIONAL MATCH (ms)-[:BALANCE]-[:Collateral {marginType:'variation',status:'pending',assetType:'NonCash'}]-[:LATEST]->(variationPendingNonCash:CollateralValue)
OPTIONAL MATCH (ms)-[:BALANCE]-[:Collateral {marginType:'variation',status:'settled',assetType:'cash'}]-[:LATEST]->(variationSettledCash:CollateralValue)
OPTIONAL MATCH (ms)-[:BALANCE]-[:Collateral {marginType:'variation',status:'settled',assetType:'NonCash'}]-[:LATEST]->(variationSettledNonCash:CollateralValue)


WITH *, CASE WHEN line.MarginType = 'Initial' THEN [1] ELSE [] END as initial
WITH *, CASE WHEN line.MarginType = 'Variation' AND (a.type = 'legacy' OR a.type = 'bilateral') THEN [1] ELSE [] END as variation1
WITH *, CASE WHEN line.MarginType = 'Variation' AND (a.type <> 'legacy' AND a.type <> 'bilateral') THEN [1] ELSE [] END as variation2
WITH *, CASE WHEN line.MarginType = 'InterestPayment' THEN [1] ELSE [] END as IP
WITH *, CASE WHEN line.MarginType = 'ProductCashFlow' THEN [1] ELSE [] END as PCF
WITH *, CASE WHEN line.MarginType = 'PAI' THEN [1] ELSE [] END as PAI
WITH *, CASE WHEN line.MarginType = 'FeesAndComms' THEN [1] ELSE [] END as FC

FOREACH (i in initial | MERGE (mc:InitialMargin:StatementItem:MarginCall {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, excessAmount:toFloat(line.ExcessAmount), marginAmount:toFloat(line.TotalCallAmount), marginAmount:toFloat(line.TotalCallAmount), returnAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.DeliverAmount), exposure:toFloat(line.Exposure), IMRole:line.IMRole, exchangeRequirement:toFloat(line.Exposure), brokerRequirement:toFloat(line.Exposure)*a.brokerMultiplier})
SET mc.initialBalanceCash = CASE WHEN initialSettledCash IS NULL THEN 0 ELSE initialSettledCash.amount END,
	mc.initialBalanceNonCash = CASE WHEN initialSettledNonCash IS NULL THEN 0 ELSE initialSettledNonCash.amount END,
	mc.balanceAmount = mc.initialBalanceCash + mc.initialBalanceNonCash,
	mc.pendingCollateral = initialPendingCash+initialPendingNonCash
)

FOREACH (i in variation1 | MERGE (mc:VariationMargin:StatementItem:MarginCall {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, excessAmount:toFloat(line.ExcessAmount), marginAmount:toFloat(line.TotalCallAmount), marginAmount:toFloat(line.TotalCallAmount), returnAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.DeliverAmount), 
	exposure:toFloat(line.Exposure), ampId:line.AmpId})
SET mc.variationBalanceCash = CASE WHEN variationSettledCash IS NULL THEN 0 ELSE variationSettledCash.amount END,
	mc.variationBalanceNonCash = CASE WHEN variationSettledNonCash IS NULL THEN 0 ELSE variationSettledNonCash.amount END
)

FOREACH (i in variation2 | MERGE (mc:VariationMargin:StatementItem:MarginCall {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, excessAmount:toFloat(line.ExcessAmount), marginAmount:toFloat(line.TotalCallAmount), marginAmount:toFloat(line.TotalCallAmount), returnAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.ReturnAmount), deliverAmount:toFloat(line.DeliverAmount), 
	exposure:toFloat(line.Exposure), ampId:line.AmpId})
SET mc.variationBalanceCash = CASE WHEN variationSettledCash IS NULL THEN 0 ELSE variationSettledCash.amount END,
	mc.variationBalanceNonCash = CASE WHEN variationSettledNonCash IS NULL THEN 0 ELSE variationSettledNonCash.amount END
)

FOREACH (i in IP | MERGE (mc:InterestPayment:StatementItem {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, marginAmount:toFloat(line.TotalCallAmount)}))

FOREACH (i in PCF | MERGE (mc:ProductCashFlow:StatementItem {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, totalCouponPayment:toFloat(line.TotalCouponPayment), upfrontFee:toFloat(line.UpfrontFee), premiumPayment:toFloat(line.PremiumPayment), CDSCreditEvent:toFloat(line.CDSCreditEvent), NDFCashSettlement:toFloat(line.NDFCashSettlement), marginAmount:toFloat(line.TotalCallAmount)}))

FOREACH (i in PAI | MERGE (mc:PAI:StatementItem {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, marginAmount:toFloat(line.TotalCallAmount)}))

FOREACH (i in FC | MERGE (mc:FeesAndComms:StatementItem {id:line.CallId, callDate:line.CallDate, marginType:line.MarginType, direction:line.Direction, side:line.Side, currency:line.Currency, valuationDate:line.ValuationDate, parentRank:1, clearingFee:toFloat(line.ClearingFee), brokerFee:toFloat(line.BrokerFee), marginAmount:toFloat(line.TotalCallAmount)}))

WITH *

MATCH (mc:StatementItem {id:line.CallId})

SET mc.notificationTime = mc.callDate + 'T' + a.notificationTime

MERGE (mc)-[:FIRST]->(step1:Step {status:'Unrecon'})
MERGE (mc)-[:LAST]->(step1)

MERGE (mc)-[:PART_OF]->(ms)

WITH *

MATCH (step2:Step {status:'Expected'})<-[r:LAST]-(mce:StatementItem {callDate:line.CallDate, marginType:line.MarginType, status:'Expected', currency:line.Currency})-[:PART_OF]->(ms)

DELETE r

MERGE (step2)-[:NEXT]->(:Step {status:'MatchedToReceived'})<-[:LAST]-(mce)

MERGE (mce)<-[:MATCHED_TO_EXPECTED]-(mc)
